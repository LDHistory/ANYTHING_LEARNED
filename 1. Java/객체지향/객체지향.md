# 객체지향

## 목차
[1. 객체](#1-객체) </br>
[2. 객체 지향 프로그래밍의 특징](#2-객체-지향-프로그래밍의-특징) </br>
[3. 클래스의 구성 멤버](#3-클래스의-구성-멤버) </br>
[4. 생성자](#4-생성자) </br>
[5. 메소드](#5-메소드) </br>
[6. 인스턴스 멤버와 this](#6-인스턴스-멤버와-this) </br>
[7. 정적 멤버와 static](#7-정적-멤버와-static) </br>
[8. 상수 final static](#8-상수final-static) </br>
[9. Annotation](#9-annotation)
___

## 1. 객체
소프트웨어를 개발할 때 부품에 해당하는 객체들을 만들고, 이것들을 조립해서 하나의 프로그램을 만드는 기법을 객체 지향 프로그래밍(OOP)라고 한다.

객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 __자신의 속성__ 을 가지고 있고 다른 것과 식별 가능한 것을 말한다. 객체는 __속성__ 과 __동작__ 으로 구성되어 있다. 자바는 이 속성과 동작들을 각각 __Field__ 와 __Method__ 라고 부른다.

현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링(Object Modeling)이라고 하며, 현실 세계의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정을 말한다.
___

## 2. 객체 지향 프로그래밍의 특징
### 2.1 캡슐화(Encapsulation)
캡슐화란 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것을 말한다. __외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.__

캡슐화의 목표는 __클래스 내 필드와 메소드를 보호하여 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.__ 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 __접근 제한자(Access Modifier)를 사용한다.__ 접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 객체를 보호할 수 있다.

### 2.2 상속(Inheritance)
상속은 부모가 가지고 있는 필드 및 메소드를 하위 객체에게 물려준다. 상속은 상위 객체를 __재사용__ 해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 반복된 __코드의 중복__ 을 방지할 수 있다.

또한 상위 객체를 수정함으로써 모든 하위 객체들의 수정 효과를 가져올 수 있으므로 __유지 보수 시간__ 을 최소화시켜준다. 예를 들어, 객체 B, C가 객체 A를 상속할 경우 A의 필드와 메소드를 수정함으로써 객체 B, C를 수정하지 않아도 객체 A의 수정된 필드와 메소드를 사용할 수 있다.

### 2.3 다형성(Polymorphism)
다형성은 __같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.__ 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있다. Java는 다형성을 위해 __부모 클래스 또는 인터페이스의 타입 변환__ 을 허용한다. 따라서 객체는 부품처럼 사용할 수 있어 기능 확장이 용이하게 된다.
___

## 3. 클래스의 구성 멤버
객체를 사용하기 위해선 __설계도__ 역할을하는 Class를 생성해야 한다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되며, 클래스로부터 만들어진 객체를 해당 클래스의 __인스턴스(instance)__ 라고 한다.
```java
public class ClassName {
    // 필드 : 객체의 데이터가 저장되는 곳
    int fieldName;

    // 생성자 : 객체 생성 시 초기화 역할 담당
    ClassName() { ... }

    // 메소드 : 객체의 동작에 해당하는 실행 블록
    void methodName() { ... }

}
```
___

## 4. 생성자
생성자(Constructor)는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 객체 초기화란 필드를 초기화하거나, 메소드를 호출해서 객체를 사용 준비를 하는 것을 말한다.

__생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.__ new 연산자에 의해 성성자가 성공적으로 실행되면 __Heap 영역__ 에 객체가 생성되고 객체의 주소가 리턴된다.

### 4.1 기본 생성자
___
모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 아래와 같은 기본 생성자를 바이트 코드에 자동으로 추가시킨다.

```java
[public] 클래스() {}
```
생성자가 public class로 선언되면 기본 생성자에도 public이 붙지만, 클래스가 기본 class로 선언되면 기본 생성자에도 public이 붙지 않는다.

클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않는다. 클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다.

```java
public class Car {
    // 생성자
    Car(String model, String color, int speed) { ... }
}

public class Sample {
    public static void main(String[] args) {
        Car car = new Car("Genesis", "Blue", 300);
        // Car car = new Car(); (X)
    }
}
```

### 4.2 this
___
외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다. 자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공한다.

```java
public class 클래스 {

    클래스 (int a) {
        ...
    }

    클래스 (int a, int b) {
        ...
    }

    ...

}
```

그러나 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다. 매개 변수의 수만 달리하고 필드 초기화 내용이 비슷한 생성자에서 이러한 현상을 많이 볼 수 있다. 이 경우에는 필드 초기화 내용은 한 생성자에만 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.

__이때 생성자에서 다른 생성자를 호출할 때 아래와 같이 this()를 사용한다.__

```java
클래스 ([매개변수], ...) {
    this(매개변수1, 매개변수2, ...);
    샐행문;
}
```
__this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.__

```java
public class Car {
    String model;
    String color;
    int speed;

    Car(String model) {
        this(model, "blue", 300);
    }

    Car(String model, String color) {
        this(model, color, 300);
    }

    Car(String model, String color, int speed) {
        this.model = model;
        this.color = color;
        this.speed = speed;
    }
}
```
___

## 5. 메소드
메소드는 객체의 동작에 해당되며, 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
```java
리턴타입 메소드이름([매개변수, ...]) {
    // 로직
}
```

메소드의 매개 변수는 개수가 이미 정해져 있는 것이 일반적이지만, 경우에 따라서는 메소드를 선언할 때 매개 변수를 알 수 없는 경우가 있다. 이럴경우 배열을 통해 전달하게 된다.

```java
int sum(int[] values) { ... }
```

이럴경우 매개 변수를 객체 타입으로 생성해야하는 불편함이 있다. 따라서 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법이 존재하는데, 다음과 같이 매개 변수를 .__...__ 을 사용한다.

```java
int sum(int ...values) { ... }

int result = sum(1, 2);
int result = sum(1, 2, 3);
```
___

## 6. 인스턴스 멤버와 this
인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이를 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.

```java
public class Car {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.name = "Genesis";
        myCar.setName("G70");

        Car yourCar = new Car();
        yourCar.name = "Genesis";
        yourCar.setName("GV70");
    }
}
```

인스턴스 필드 name은 __객체마다 따로 존재__ 하고, 인스턴스 메소드 setName은 __객체마다 존재하지 않고 메소드 영역에 저장되고 공유__ 된다.

객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 __객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용__ 할 수 있다.
___

## 7. 정적 멤버와 static
static은 '고정된'이란 의미를 가지고 있으며, 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다.

정적 멤버는 인스턴스에 소속된 멤버가 아니라 __클래스에 소속된 멤버이기 떄문에 클래스멤버__ 라고도 한다.
```java
public class 클래스 {

    static 타입 필드 [= 초기값];

    static 리턴타입 메소드(매개변수, ...) {
        ...
    }

}
```

정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 __클래스 로더가 Byte코드를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.__ 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

### 7.1 정적 초기화 블록
___
정적 필드는 선언과 동시에 초기값을 주는 것이 보통이다.
```java
static double pi = 3.141592;
```

그러나 계산이 필요한 초기화 작업이 있을 수 있다. 인스턴스 필드는 생성자에서 초기화하지만, 정적 필드는  객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다. __생성자는 객체 생성 시에만 실행되기 때문이다.__

정적 필드의 복잡한 초기화 작업을 위해서 정적 블록(static block)을 제공한다.
```java
static {
    ...
}
```
정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에 여러개가 선언되더라도 상관없다. 클래스가 메모리로 로딩될 떄 선언된 순서대로 실행된다.

```java
public class Sample {
    static String company = "HYUNDAI";
    static String model = "Genesis";
    static String info;

    static {
        info = company + "-" + model;
        print();
    }

    static void print() {
        System.out.println(info);
    }
}
```
___

## 8. 상수(final static)
상수는 불변의 값을 저장하는 필드를 가리킨다. final 필드는 한 번 초기화되면 수정할 수 없는 필드가 된다.

단순히 final 키워드가 붙은 필드를 상수라고 부르진 않는다. __불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러 가지 값으로 초기화될 수 없기 때문이다.__ final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다.

상수는 __static이면서 final이어야 한다.__ static final 필드는 객체마다 저장되지 않고, 클래스에만 포함된다. 그리고 한 번 초기값이 저장되면 변경할 수 없다.

```java
static final 타입 상수 [= 초기값];
```

초기값이 단순 값이라면 선언 시에 주는 것이 일반적이지만, 복잡한 초기화일 경우 정적 블록에서도 할 수 있다.

```java
static final String A;

static {
    A = "Genesis";
}
```
상수 이름은 모두 대문자로 작성하는 것이 관례이다. 만약 서로 다른 단어가 혼합된 이름이라면 언더바(_)로 단어들을 연결해준다.
___

## 9. Annotation
어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다. 메타데이터란 애플리케이션이 처리해야 할 데이터가 아니라, __컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할것인지를 알려주는 정보이다.__
```java
@AnnotationName
```

어노테이션은 다음과 같은 용도로 사용된다.

1. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
2. 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
3. 런타임시 특정 기능을 실행하도록 정보를 제공

컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 대표적인 예는 @Override 어노테이션이다. @Override는 메소드 선언 시 사용하는데, 메소드가 오버라이드된 것임을 컴파일러에게 알려주어 컴파일러가 오버라이드 검사를 하도록 해준다. 정확히 오버라이드가 되지 않았다면 컴파일러는 에러를 발생시킨다.

### 9.1 어노테이션 타입 정의와 적용
___
어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다.
```java
public @interface AnnotationName {
}
```

위에서 정의한 어노테이션은 코드에서 아래와 같이 사용한다.
```java
@AnnotationName
```

어노테이션은 Element를 멤버로 가질 수 있다. 각 Element는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.

```java
public @interface AnnotationName {
    String elementName() [default 값];
}

public @interface AnnotationName {
    String name() default "Genesis";
}
```

위에서 정의한 Element를 적용할 때에는 다음과 같이 기술한다.

```java
@AnnotationName(name = "G70")
```

### 9.2 어노테이션 적용 대상
___
어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거 상수로 정의된다.

|열거 상수|설명|
|---|---|
|TYPE|클래스, 인터페이스, 열거 타입|
|ANNOTATION_TYPE|어노테이션|
|FIELD|필드|
|CONSTRUCTOR|생성자|
|METHOD|메소드|
|LOCAL_VARIABLE|로컬 변수|
|PACKAGE|패키지|

어노테이션이 적용될 대상을 지정할 떄에는 @Target 어노테이션을 사용한다. @Target의 기본 Element인 value는 ElementType 배열을 값으로 가진다.
```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
public @interface AnnotationName {
}
```

### 9.3 어노테이션 유지 정책
___
어노테이션 정의 시 한 가지 더 추가해야 할 내용은 사용 용도에 따라 어느 범위까지 유지할 것인지 지정해야 한다. 소스상에서만 유지할 건지, 컴파일된 클래스까지 유지할 건지, 런타임 시에도 유지할 건지를 지정해야 한다. 어노테이션 유지 정책은 java.lang.annotation.RetentionPolicy 열거 상수로 다음과 같이 정의되어 있다.

|열거 상수|설명|
|---|---|
|SOURCE|소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다.|
|CLASS|바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.|
|RUNTIME|바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다.|

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationName {
}
```

### 9.4 런타임 시 어노테이션 정보 사용하기
___
런타임 시에 어노테이션이 적용되었는지 확인하고 Element 값을 이용해서 특정 작업을 수행 할 수 있다. 어노테이션 자체는 아무런 동작을 가지지 않는 단지 표식일 뿐이지만, 리플렉션을 이용해서 어노테이션의 적용 여부와 Element 값을 읽고 적잘히 처리할 수 있다.

|리턴 타입|메소드|설명|
|---|---|---|
|boolean|isAnnotationPresent(Class<? extends Annotation> annotationClass|지정한 어노테이션이 적용되었는지 여부.
|Annotation|getAnnotation(Class<T> annotationClass)|지정한 어노테이션이 적용되어 있으면 어노테이션을 리턴하고 그렇지 않다면 null을 리턴.|
|Annotation[]|getAnnotations()|적용된 모든 어노테이션을 리턴. Class에서 호출했을 때 상위 클래스에 적용된 어노테이션 모두 포함.|
|Annotation[]|getDeclaredAnnotations()|직접 적용된 모든 어노테이션을 리턴. Class에서 호출했을 때 상위 클래스에 적용된 어노테이션을 포함되지 않음.|

> 참조 : 이것이 자바다(신용권의 Java 프로그래밍 정복)
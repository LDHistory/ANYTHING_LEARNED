# 인터페이스

## 목차
[1. 인터페이스 역할](#1-인터페이스-역할) </br>
[2. 인터페이스 선언](#2-인터페이스-선언) </br>
[3. 인터페이스 구현](#3-인터페이스-구현) </br>
[4. 인터페이스 사용](#4-인터페이스-사용) </br>
[5. 타입 변환과 다형성](#5-타입-변환과-다형성) </br>
[6. 인터페이스 상속](#6-인터페이스-상속) </br>
[7. 디폴트 메소드와 인터페이스 확장](#7-디폴트-메소드와-인터페이스-확장)
___

## 1. 인터페이스 역할
인터페이스(interface)는 객체의 __사용 방법__ 을 정의한 타입니다. 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는데 매우 중요한 역할을 한다.

인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 매소드를 호출시킨다. __그렇기 때문에 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다.__

개발 코드가 직접 객체의 메소드를 호출하지 않고 인터페이스를 호출하는 이유는 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기 위함이다. 인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라서 실행 내용과 리턴값이 다를 수 있다. 따라서 개발 코드 측면에서 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다.

___

## 2. 인터페이스 선언
```
[ public ] interface 인터페이스명 { ... }
```
클래스는 필드, 생성자, 메소드를 구성 멤버로 가지는데 비해, 인터페이스는 상수와 메소드만을 구성 멤버로 가진다. 인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없다.
> 자바 7이전까지는 인터페이스의 메소드는 실행 블록이 없는 추상 메소드로만 선언이 가능했지만, 자바 8부터는 __디폴트 메소드와 정적 메소드도 선언이 가능하다.__

```java
interface 인터페이스명 {
    // 상수
    타입 상수명 = 값;

    // 추상 메소드
    타입 메소드명(매개변수, ...);

    // 디폴트 메소드
    default 타입 메소드명(매개변수, ...) { ... }

    static 타입 메소드명(매개변수, ...) { ... }
}
```

### 2.1 상수 필드
인터페이스는 데이터를 저장할 수 없기 때문에 데이터를 저장할 인스턴스 또는 정적 필드를 선언할 수 없다. 대신 상수 필드만 선언할 수 있다. 인터페이스에 선언된 필드는 모두 __public static final__ 의 특성을 갖는다. public, static, final을 생략하더라도 자동적으로 __컴파일 과정에서 붙게 된다.__

```
[ public static final ] 타입 상수명 = 값;
```

상수명은 대문자로 작성하되, 서로 다른 단어로 구성되어 있을 경우에는 언더바(_)로 연결하는 것이 관례이다.

```java
public interface RemoteControl {
    // 상수 필드
    public int MAX_VOLUME = 10;
    public int MIN_VOLUME = 0;
}
```

### 2.2 추상 메소드
인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행된다. 그렇기 때문에 인터페이스의 메소드는 실행 블록이 필요 없는 추상 메소드로 선언한다. 인터페이스에 선언된 추상 메소드는 모두 public abstract의 특성을 갖기 때문에 public abstract을 생략하더라도 자동적으로 __컴파일 과정에서 붙게 된다.__

```java
public interface RemoteControl {
    // 상수 필드
    public int MAX_VOLUME = 10;
    public int MIN_VOLUME = 0;

    // 추상 메소드
    public void turnOn();
    public void turnOff();
    public void setVolume(int volume);
}
```
___

### 2.3 디폴트 메소드
디폴트 메소드는 자바 8에서 추가된 인터페이스의 새로운 멤버이다. 형태는 클래스의 인스턴스 메소드와 동일한데, default 키둬드가 리턴 타입 앞에 붙는다. 디폴트 메소드는 public 특성을 갖기 때문에 public을 생략하더라도 자동적으로 __컴파일 과정에서 붙게 된다.__

```
[ public ] default 리턴타입 메소드명(매개변수, ...) { ... }
```

```java
public interface RemoteControl {
    // 상수 필드
    public int MAX_VOLUME = 10;
    public int MIN_VOLUME = 0;

    // 추상 메소드
    public void turnOn();
    public void turnOff();
    public void setVolume(int volume);

    // 디폴트 메소드
    default void setMute(boolean mute) {
        if (mute) {
            System.out.println("Mute mode on.");
        } else {
            System.out.println("Mute mode off.");
        }
    }
}
```
___

### 2.4 정적 메소드 선언
정적 메소드는 디폴트 메소드와 마찬가지로 자바 8에서 추가된 인터페이스의 새로운 멤버이다. 정적 메소드는 public 특성을 갖기 때문에 public을 생략하더라도 자동적으로 __컴파일 과정에서 붙게 된다.__

```
[ public ] static 리턴타입 메소드명(매개변수, ...) { ... }
```

```java
public interface RemoteControl {
    // 상수 필드
    public int MAX_VOLUME = 10;
    public int MIN_VOLUME = 0;

    // 추상 메소드
    public void turnOn();
    public void turnOff();
    public void setVolume(int volume);

    // 디폴트 메소드
    default void setMute(boolean mute) {
        if (mute) {
            System.out.println("Mute mode on.");
        } else {
            System.out.println("Mute mode off.");
        }
    }

    // 정적 메소드
    static void changeBattery() {
        System.out.println("Change Battery...");
    }
}
```

___

## 3. 인터페이스 구현
개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다.

구현 클래스는 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 implements 키워드를 추가하고 인터페이스명을 명시해야 한다.

```java
public class 클래스명 implements 인터페이스명 {
    ...
}
```

```java
public class Television implements RemoteControl {
    
    public void turnOn() {
        // Something TODO...
    }

    public void turnOff() {
        // Something TODO...
    }

    public void setVolume(int volume) {
        // Something TODO...
    }
}
```

구현 클래스에서 인터페이스의 추상 메소드들에 대한 실체 메소드를 작성할 때 주의할 점은 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에 public보다 낮은 접근 제한자를 사용할 수 없다.

만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지 않으면 __구현 클래스는 자동적으로 추상 클래스가 된다.__ 따라서 클래스 선언부에 abstract 키워드를 추가해야 한다.

```java
public abstract class Television implements RemoteControl {
    // setVolume 메소드를 구현하지 않았기 때문에 해당 클래스는 추상 클래스로 선언해야한다.
    public void turnOn() { ... }
    public void turnOff() { ... }
}
```

### 3.1 익명 구현 객체
구현 클래스를 만들어 사용하는 것이 일반적이고, 클래스를 재사용할 수 있기 떄문에 편리하지만, 일회성의 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다.

자바는 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법을 제공하는데, 그것이 익명 구현 객체 이다. 이러한 방식을 이용하는것이 자바 8에서 제공해주는 람다식이다.

```
인터페이스 변수 = new 인터페이스() {
    // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

인터페이스를 new 연산자를 통해 인터페이스를 구현한다. __중괄호 안에는 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야한다.__ 그렇지 않으면 컴파일 에러가 발생한다.

```java
public class Main {
    public static void main(String[] args) {
        RemoteControl rc = new RemoteControl() {
            public void turnOn() {
                // Something TODO...
            }

            public void turnOff() {
                // Something TODO...
            }

            public void setVolume(int volume) {
                // Something TODO...
            }
        }
    }
}
```

### 3.2 다중 인터페이스 구현 클래스
객체는 다수의 인터페이스 타입을 사용할 수 있다. 인터페이스 A와 인터페이스B가 객체의 메소드를 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야 한다.

```java
public class 구현클래스 implements 인터페이스A, 인터페이스B {
    // 인터페이스A에 선언된 추상 메소드와 실체 메소드 선언
    // 인터페이스B에 선언된 추상 메소드와 실체 메소드 선언
}
```

다중 인터페이스를 구현할 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 한다. 만약 하나라도 없으면 추상 클래스로 선언해야 한다.
___

## 4. 인터페이스 사용
```
인터페이스 변수;
변수 = 구현객체;
```
예를 들어 RemoteControl 인터페이스로 구현 객체인 Television과 Audio를 사용하려면 다음과 같이 RemoteControl 타입 변수 rc를 선언하고 구현 객체를 대입해야 한다.

```java
RemoteControl rs;
rc = new Television();
rc = new Autio();
```

### 4.1 디폴트 메소드 사용
디폴트 메소드는 인터페이스에 선언되지만, 인터페이스에서 바로 사용할 수 없다. 디폴트 메소드는 추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다. 예를 들어 RemoteControl 인터페이스는 setMeute() 라는 디폴트 메소드를 가지고 있지만, 이 메소드를 다음과 같이 호출할 수는 없다.

```java
RemoteControl.setMute(true);
```

즉, 구현 객체를 생성 후 인스턴스 변수에 대입하고 나서 호출할 수 있다.

```java
RemoteControl rc = new Television();
rc.setMute(true);
```
디폴트 메소드는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드라고 생각하면 된다.

### 4.2 정적 메소드 사용
인터페이스 정적 메소드는 인터페이스로 바로 호출이 가능하다.

```java
RemoteControl.changeBattery();
```

___

## 5. 타입 변환과 다형성
다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질을 말한다. 부모 타입에 어떤 자식 객체를 대입하느냐에 따라 실행 결과가 달라지듯이, 인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다.

프로그램을 개발할 떄 인터페이스를 사용해서 메소드를 호출하도록 코딩을 했다면, 구현 객체를 교체하는 것은 매우 쉬워진다. 소스 코드는 변함이 없는데, 구현 객체를 교체함으로써 프로그램의 실행 결과가 다양해지는데 이것이 __인터페이스의 다형성__ 이다.

### 5.1 자동 타입 변환
구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환에 해당한다. 자동 타입 변환은 프로그램 실행 도중에 자동적으로 타입 변환이 일어난다.

```java
인터페이스 변수 = 구현객체; // 자동 타입 변환
```

인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었따면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환시킬 수 있다.

### 5.2 강제 타입 변환
구현 객체가 인터페이스 타입으로 자동 변환하면, 인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항이 따른다.
하지만 경우에 따라서는 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우도 발생한다. 이때 강제 타입 변환을 해서 다시 구현 클래스 타입으로 변환한 다음, 구현 클래스의 필드와 메소드를 사용할 수 있다.

```java
구현클래스 변수 = (구현클래스) 인터페이스변수; // 강제 타입 변환 
```
___

## 6. 인터페이스 상속
인터페이스도 다른 인터페이스를 상속할 수 있다. 인터페이스는 클래스와는 달리 다중 상속을 허용한다.

```java
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 { ... }
```

하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드뿐만 아니라 슁이 언터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.

```
하위인터페이스 변수 = new 구현클래스(...);
상위인터페이스1 변수 = new 구현클래스(...);
상위인터페이스2 변수 = new 구현클래스(...);
```
하위 인터페이스로 타입 변환이 되면 상,하위 인터페이스에 선언된 모든 메소드를 사용할 수 있으나, 상위 인터페이스로 타입 변환되면 상위 인터페이스에 선언된 메소드만 사용 가능하고 하위 인터페이스에 선언된 메소드는 사용할 수 없다.
___

## 7. 디폴트 메소드와 인터페이스 확장
디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용할 수 있다. 선언은 인터페이스에서 하고, 사용은 구현 객체를 통해 사용해야한다. 디폴트 메소드는 모든 구현 객체에서 공유하는 기본 메소드처럼 보이지만, 인터페이스에서 디폴트 메소드를 허용한 다른 이유가 있다.

그 이유는, 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위함이다. 기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 개발한 구현 클래스를 그대로 사용할 수 있으면서 새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다.

예를 들어, interfaceA에 아래와 같이 2개의 메소드가 있다고 가정하자.

```java
public interface interfaceA {
    public void method1();
}
```

이를 상속받는 classA는 아래와 같은 모야이 된다.

```java
public class classA implements interfaceA {
    @Override
    public void method1() {
        // Something TODO...
    }
}
```

이후에 interfaceA가 새로운 추상 메서드가 추가가 되어 배포가 나간다고 하자.

```java
public interface interfaceA {
    public void method1();
    public void method2();
}
```

이럴경우 기존 classA는 method2()를 구현하지 않았기 때문에 문제가 발생된다. 그래서 새로운 기능을 확장할 때 사용할 수 있는데 디폴트 메소드이다. __디폴트 메소드는 추상 메소드가 아니기 때문에 구현 클래스에서 실체 메소드를 작성할 필요가 없다.__

> 참조 : 이것이 자바다(신용권의 Java 프로그래밍 정복)


# 시간 복잡도와 언어별 유의사항

## 효율성
알고리즘 문제를 해결하는 어떤 코드를 작성했을 때, 이 프로그램이 얼마나 효율적인지 알고 싶다.
1. 수행시간
2. 사용한 메모리
___
- 어떤 프로그램을 작성했는데, 시간이 30일이 걸리면 정말로 30일 동안 실행시켜야 한다.
- 어떤 프로그램을 작성했는데, 메모리가 64GB 필요한데, 메모리가 부족하면 램을 구매하면 된다.
- 이런 이유 떄문에 문제를 해결할 떄는 시간이 중요하다.
> 메모리는 돈을주고 살 수 있지만 시간은 대체를 할 수 없다.</br>
이러한 이유 떄문에 수행시간이 매우 중요하다.
___
</br>

## 문제의 크기
- 개발 상황에서 접하게 되는 상황은 문제를 해결하는 것이고, 항상 문제의 크기가 존재한다.
- 예르들어 쇼핑몰의 장바구니 물건의 개수가 될 수 있고,
- 게임 동시 접속자의 수가 될 수 있다.
- 이러한 문제의 크기를 보통 N이라고 하고, 문제의 크기 N에 따라 걸리는 시간이 다르다.
> 이러한 이유 때문에 문제를 해결할 때는 문제의 크기를 먼저 보고 방법을 생각해야 한다.
___
</br>

## 시간 복잡도
시간 복잡도를 이용하면 작성한 코드가 시간이 대략 얼마나 걸릴지 예상할 수 있다.
- 표기법으로 대문자 O를 사용한다. (다양한 시간 복잡도가 있지만, 보통 Big-O만 사용한다.)
- 입력의 크기 N에 대해서 시간이 얼마나 걸릴지 나타내는 방법.
</br>

> **예시**</br>
총 N명의 사람이 식당에 방문했다. </br>
식당에는 메뉴가 M개 있고, 메뉴판이 1개 있다. </br>
사람 1명이 메뉴판을 읽는데 걸리는 시간은 O(M)이다.


```
// 해당 코드는 1부터 N까지 합을 구해야 하므로 O(N)이 된다.
int sum = 0;
for (int i = 1; i <= N++) {
    sum += i;
}
```
```
// 이러한 경우는 더하고, 곱하고, 나눠주는 작업만 하기 때문에 O(1)이 된다.
int sum = 0;
sum = N*(N+1)/2;
```
> Big O 표기법에서 상수는 버린다. </br>
O(3N^2) = O(N^2) </br>
O(1/2N^1) = O(N^2)

> 두 가지 항이 있을 때, 변수가 같으면 큰 것만 뺴고 다 버린다.</br>
O(N^2 + N) = O(N^2)

> 두 가지 항이 있는데 변수가 다르면 놔둔다.</br>
O(N^2 + M) = O(N^2 + M)
___
</br>

## 메모리
메모리 제한은 보통 넉넉하기 떄문에, 걱정할 필요가 없다. </br>
대략적으로 얼마나 공간을 사용할지 예상할 수는 있다.
- 보통 가장 많은 공간을 사용하는 것은 배열이다.
- 배열이 사용한 공간 : 배열의 크기 * 자료형의 크기 (Byte)

보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다. </br>
불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다.
___
</br>

## 입/출력
- Java는 입력을 Scanner, 출력은 System.out을 사용한다. </br>
``` Scanner sc = new Scanner(System.in); ```
- 입력이 많은 경우에는 속도가 느리기 떄문에, BufferedReader를 사용한다. </br>
``` BufferedReader br = new BufferedReader(new InputStreamReader(System.in); ```
- 출력이 많은 경우에는 StringBuilder를 사용해서 한 문자열로 만들어서 출력을 한 번만 사용한다.


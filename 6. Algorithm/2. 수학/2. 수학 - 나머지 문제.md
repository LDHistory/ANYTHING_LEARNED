# 수학

## 나머지 연산
- 컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제가 등장한다.
- (A + B) % M = ((A % M) + (B % M)) % M
> A = 4, B = 7, M = 3 </br>
(4 + 7) % 3 = 11 % 3 = 2 </br>
(4 % 3 + 7 % 3) % 3 = (1 + 1) % 3 = 2

- (A * B) % M = ((A % M) * (B % M)) % M
> A = 4, B = 7, M = 3 </br>
(4 * 7) % 3 = 1
(4 % 3 * 7 % 3) % 3 = (1 * 1) % 3 = 1
</br>
- 나누기의 경우에는 성립하지 않는다. (Modular Inverse를 구해야 함) </br>
- 뺼셈의 경우에는 먼저 mod연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 해야 한다. </br>
> (A-B) % M = ((A % M) - (B % M) + M) % M </br>
0 <= A % M < M </br>
0 <= B % M < M </br></br>
이 두 수를 뺄 경우 아래와 같아진다. </br>
-M <= A%M - B%M < M </br></br>
이후 -M을 제거하면 아래와 같아진다.</br>
0 <= A%M - B%M + M < 2M </br>
즉, 항상 양수가 나오게 된다. 따라서 M을 추가로 더해줘야 한다.

문제에서 '정답을 ~~~로 나눈 나머지를 출력하라' 라는 말이 있는 이유는 정답이 int나 long과 같은 자료형의 범위를 넘어가기 떄문이다. 따라서 앞에서 본 것처럼 매번 나누면 된다.
</br>

> 참조문제
P_4375
___
</br>

## 약수
- 두 자연수 A와 B가 있을 때, A=BC를 만족하는 자연수 C를 A의 약수라고 한다.
- C가 A의 약수라면, A/C도 A의 약수가 되어야 한다. 즉, 나눴을 때 나머지가 0일 경우 몫도 약수가 된다.
- C = A / C -> C^2 = A
- 만약 어떤 자연수 N에 대해서 약수를 찾게 될 경우 루트N까지만 구해도 약수를 모두 구할 수 있다.
</br>

> 참조문제
P_1037, P_17427
___
</br>

## 최대공약수
최대 공약수는 줄여서 GCD라고 한다. </br>
두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다. </br>
최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A, B)까지 모든 정수로 나누어 보는 방법 </br>
최대공약수가 1인 두 수를 서로소라고 한다.
```
int g = 1;
for (int i = 2; i <= min(a, b); i++) {
    if (a % i == 0 && b % i == 0) {
        g = i;
    }
}
```
</br>
또 다른 방법으로는 유클리드 호제법을 이용하는 방법이다. </br>
a를 b로 나눈 나머지를 r이라고 할 때 GCD(a, b) = GCD(b, r)과 같다. </br>
r이 0이면 그 때 b가 최대 공약수 이다. </br>

> GCD(24,16) = GCD(16,8) = GCD(8,0) = 8

</br>

- 재귀함수를 통한 유클리드 호제법
```
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a%b);
    }
}
```
</br>

- 반복문을 통한 유클리드 호제법
```
int gcd(int a, int b) {
    while (b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }

    return a;
}
```
</br>

> 만약 세 수의 최대공약수를 구할 경우 아래와 같다. </br>
GCD(a, b, c) = GCD(GCD(a, b), c)
</br>

> 참조문제
P_2609
___
</br>

## 최소공배수
최소공배수는 줄여서 LCM이라고 한다.</br>
두 수의 최소공배수는 두 수의 공통된 배수 중에서 가장 작은 정수가 된다. </br>
최소공배수는 GCD를 응용해서 구할 수 있다. </br>
두 수 a,b의 최대공약수를 g라고 할 때 최소공배수 l = g * (a/g) * (b/g)이다.
</br>

> 참조문제
P_2609
___
</br>

## 소수
소수는 약수가 1과 자기 자신 밖에 없는 수를 나타낸다. </br>
N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안 된다.
</br>

- 어떤 수 N이 소수인지 구하는 방법
> 1과 N을 제외하고 가장 작은 약수는 2가 되는데, 이때 약수의 성질로 루트 N을 기점으로 서로 나눠지기 떄문에 </br>
2부터 루트N까지 사이에서 나눴을 때 0이 안나오면 된다. 이때 시간복잡도는 O(루트N)이 된다. </br>
실제로 루트N까지 비교하지 않아도 된다. i <= 루트N일 경우 서로 제곱을 하게 되면 i^2 = N이 되므로 </br>
i의 제곱근부터 N까지를 구하면 된다. 루트N은 실수이기 때문에 정수보다는 정확도가 떨어질 수 있다.
```
bool prime(int n) {
    if (n < 2) {
        return false;
    }

    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }

    return true;
}
```
> 참조문제
P_1978
</br>
- N이하의 모든 소수를 구하는 방법 (에라토스테네스의 체) </br>
1. 2부터 N까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 이제 그 수의 배수를 모두 지운다.
5. 다시 2번 부터 반복하면서 지우게 되면 남은 수는 소수만 남게 된다.
> 다음 수 부터 비교를 하게 될 떈 N값의 제곱부터 확인하면 된다. 왜냐하면 N보다 작은 값은 이미 이전에서 지워졌기 때문에 비교할 필요가 없다.

에라토스테네스의 체를 구하기 위해서는 2개의 배열이 필요하다. </br>
1. 수를 지웠는지 아닌지를 저장하는 배열 (Ex. 지웠으면 true 아니면 false)
2. 소수의 목록을 유지할 배열

```
int prime[100]; // 소수 저장
int pn = 0; // 소수의 개수
bool check[101]; // 수를 지웠는지 판단하는 배열 (지웠으면 true)
int n = 100; // 100까지의 소수를 찾는다.

for (int i = 2; i*i <= n; i++) {
    if (check[i] == false) {
        prime[pn++] = i;

        // i의 배수를 지워준다.
        for (int j = i * j; j <= n; j += i) {
            check[j] = true;
        }
    }
}
```
> 참조문제
P_1929

> 참조 : 백준 - 코딩 테스트 준비
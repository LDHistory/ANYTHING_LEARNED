# 브루트 포스
모든 경우의 수를 다 해보는 알고리즘을 의미한다. 모든 경우의 수는 문제에 어떤 방법이 제공되는데, 그 방법에 대해 모든 가능성을 고려해서 계산한다. </br>
예를 들어, 비밀번호가 4자리이고, 숫자로만 이루어져 있다고 한다면
0000부터 9999까지 다 입력해보면 된다. 그 경우의 수는 10,000가지가 된다. </br>
> 브루트 포스 방법은 가능한 방법의 개수가 너무 많으면 사용하기가 어렵다.

- 브루트 포스로 문제를 풀기 위해서는 다음과 같은 3가지 단계를 생각해볼 수 있다.
1. 문제의 가능한 경우의 수를 계산해본다. </br>
- 직접 계산을 통해서 구한다. 대부분 손으로 계산해볼 수 있다.
2. 가능한 모든 방법을 다 만들어본다. </br>
- 하나도 빠짐 없이 만들어야 한다.
- 대표적으로 그냥 다 해보는 방법, for문, 순열, 재귀 호출, 비트마스크 등...
3. 각각의 방법을 이용해 답을 구해본다.

## 경우의 수
___
- N 명의 사람이 한 줄러 서는 경우의 수? </br>
1번 부터 N자리 까지 각각의 자리는 N, N-1, N-2 ... 1까지 가능성이 존재한다. 따라서 N * (N - 1) * (N - 2) ... = N! 방법이 된다. 즉 O(N!)이 된다.
- N 명의 사람 중에서 대표 두 명을 뽑는 경우의 수? </br>
N 명 중 1명, 이미 뽑힌 1사람을 제외한 N - 1명 중 1명을 구하게 되므로 (N * (N - 1)) / 2 방법이 된다. 즉 O(N^2) 가 된다.
- N 명의 사람 중에서 대표 3명을 뽑는 경우의 수? </br>
N * (N - 1) * (N - 2) / 3 * 2 * 1 = O(N^3)

> 참고 문제 
P. 2309, P_3085

## N과 M
___
- 1부터 N까지 자연수 중에서 중복 없이 M까지 고른 수열을 모두 구하는 문제
- 순서와 밀접한 브루트 포스이다.
- 재귀 함수와 연관되어 있다. 어떤 위치에 올 수 있는 수를 결정한다. </br>
  어떤 수를 결정하는데 동작되는 로직은 같기 때문에 재귀함수를 사용할 수 있다. </br>
    즉 1-N 수 중에서 아용하지 않은 수를 같은 동작을 수행하면서 결정하게 된다.

```
bool c[10]; // i를 사용했으면 true, 아니면 false
int a[10]; // 수열을 저장하는 배열, 즉 go의 index에 올 값을 저장

// index 번째의 수를 결정
void go(int index, int n, int m) {
    if (index == m) {
        // 수열을 출력
        return;
    }

    // 1부터 N까지 수 중에서 앞에서 사용하지 않은 수를 찾음
    for (int i = 1; i <= n; i++) {
        // 앞에서 이미 사용한 것은 건너뛴다.
        if (c[i]) continue;
        // 함수를 호출하기 전에 상태를 저장한다.
        c[i] = true;
        a[index] = i;
        go(index + 1, n, m);
        c[i] = false;
    }
}
```
> 참고문제 P_15649

## 재귀
___

> 참고문제 P_9095

## 백트래킹
___
더 이상 호출이 의미가 없을경우 중단시켜 효율을 증가 시킨다. </br>

> 참고문제 P_14889